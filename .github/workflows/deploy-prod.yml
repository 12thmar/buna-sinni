name: Deploy frontend to S3 + CloudFront

on:
  push:
    branches: [ "prod" ]
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    concurrency:
      group: deploy-prod
      cancel-in-progress: true
    defaults:
      run:
        working-directory: frontend

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node 20
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Install deps (incl dev)
        run: npm ci

      - name: Install & Build
        env:
          VITE_CANON_HOST: ""  # keep empty unless you intentionally canonicalize
        run: |
          npm run build
          # Sanity: ensure hashed bundle referenced by index.html exists
          JS_FILE=$(grep -o 'assets/index-[^"]*\.js' dist/index.html | head -n1)
          CSS_FILE=$(grep -o 'assets/index-[^"]*\.css' dist/index.html | head -n1)
          test -f "dist/$JS_FILE" || (echo "Missing $JS_FILE" && exit 1)
          test -f "dist/$CSS_FILE" || (echo "Missing $CSS_FILE" && exit 1)
          echo "JS_FILE=$JS_FILE" >> $GITHUB_ENV
          echo "CSS_FILE=$CSS_FILE" >> $GITHUB_ENV
          echo "Bundle refs → $JS_FILE | $CSS_FILE"

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Sync build → S3
        run: |
          aws s3 sync dist/ s3://${{ secrets.AWS_S3_BUCKET }}/ --delete

      - name: Fix MIME types + cache headers
        shell: bash
        run: |
          set -euo pipefail
          # Immutable assets
          aws s3 cp s3://${{ secrets.AWS_S3_BUCKET }}/assets/ s3://${{ secrets.AWS_S3_BUCKET }}/assets/ \
            --recursive --metadata-directive REPLACE \
            --cache-control "public,max-age=31536000,immutable"

          # Per-extension content-types
          declare -A MAP=(
            ["js"]="application/javascript"
            ["css"]="text/css"
            ["svg"]="image/svg+xml"
            ["png"]="image/png"
            ["jpg"]="image/jpeg"
            ["jpeg"]="image/jpeg"
            ["webp"]="image/webp"
            ["avif"]="image/avif"
            ["woff2"]="font/woff2"
          )
          for ext in "${!MAP[@]}"; do
            aws s3 cp s3://${{ secrets.AWS_S3_BUCKET }}/assets/ s3://${{ secrets.AWS_S3_BUCKET }}/assets/ \
              --recursive --exclude "*" --include "*.${ext}" \
              --metadata-directive REPLACE \
              --content-type "${MAP[$ext]}" \
              --cache-control "public,max-age=31536000,immutable"
          done

          # HTML should be no-cache so new builds take effect
          aws s3 cp s3://${{ secrets.AWS_S3_BUCKET }}/index.html s3://${{ secrets.AWS_S3_BUCKET }}/index.html \
            --metadata-directive REPLACE \
            --content-type "text/html" \
            --cache-control "no-cache"

      - name: Verify bundle Content-Type (S3)
        run: |
          aws s3api head-object --bucket "${{ secrets.AWS_S3_BUCKET }}" --key "$JS_FILE" \
            --query '{Key:Key,CT:ContentType,Cache:CacheControl}'
          aws s3api head-object --bucket "${{ secrets.AWS_S3_BUCKET }}" --key "$CSS_FILE" \
            --query '{Key:Key,CT:ContentType,Cache:CacheControl}'

      - name: Invalidate CloudFront (capture ID)
        env:
          DISTRIBUTION_ID: ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}
        run: |
          set -euo pipefail
          INVALIDATION_ID=$(aws cloudfront create-invalidation \
            --distribution-id "$DISTRIBUTION_ID" \
            --paths "/*" \
            --query 'Invalidation.Id' --output text)
          echo "INVALIDATION_ID=$INVALIDATION_ID" >> $GITHUB_ENV
          echo "Created invalidation: $INVALIDATION_ID"

      - name: Wait for CloudFront invalidation (no ListInvalidations)
        env:
          DISTRIBUTION_ID: ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}
        run: |
          set -euo pipefail
          if [ -z "${INVALIDATION_ID:-}" ]; then
            echo "::warning::No INVALIDATION_ID available; skipping wait."
            exit 0
          fi
          # This requires only cloudfront:GetInvalidation
          if ! aws cloudfront wait invalidation-completed \
                --distribution-id "$DISTRIBUTION_ID" \
                --id "$INVALIDATION_ID"; then
            echo "::warning::Wait failed or not permitted. Will rely on edge retries next."
          fi

      - name: Edge smoke-test (retry until fresh)
        env:
          DOMAIN: www.bunaroots.com
        run: |
          set -euo pipefail
          # Derive the paths from the built index.html (we exported these earlier, but re-derive if missing)
          JS_FILE="${JS_FILE:-$(grep -o 'assets/index-[^"]*\.js' dist/index.html | head -n1)}"
          CSS_FILE="${CSS_FILE:-$(grep -o 'assets/index-[^"]*\.css' dist/index.html | head -n1)}"
          echo "Testing https://$DOMAIN/$JS_FILE and $DOMAIN/$CSS_FILE"

          check_one() {
            local path="$1" expect="$2"
            headers=$(curl -sS -I "https://$DOMAIN/$path" || true)
            status=$(echo "$headers" | awk '/^HTTP/{print $2}' | tail -1)
            ct=$(echo "$headers" | awk -F': ' 'tolower($1)=="content-type"{print tolower($2)}' | tr -d '\r')
            body_head=$(curl -sS "https://$DOMAIN/$path" | head -c 120 || true)

            if [ "$status" != "200" ]; then
              echo "STATUS=$status for $path"
              return 1
            fi
            if [ "$expect" = "js" ] && [[ "$ct" != application/javascript* && "$ct" != text/javascript* ]]; then
              echo "Wrong CT ($ct) for $path"
              return 1
            fi
            if [ "$expect" = "css" ] && [[ "$ct" != text/css* ]]; then
              echo "Wrong CT ($ct) for $path"
              return 1
            fi
            if [[ "$body_head" == "<!DOCTYPE html>"* || "$body_head" == "<html"* ]]; then
              echo "Got HTML for $path (likely stale edge or missing object)"
              return 1
            fi
            return 0
          }

          # Retry up to ~2 minutes for edges to pick up fresh objects
          for i in $(seq 1 12); do
            echo "Attempt $i/12 ..."
            if check_one "$JS_FILE" js && check_one "$CSS_FILE" css; then
              echo "Edge OK"
              exit 0
            fi
            sleep 10
          done

          echo "::error::Edge still serving wrong content after retries."
          echo "Debug JS HEAD:"
          curl -I "https://$DOMAIN/$JS_FILE" || true
          echo "Debug CSS HEAD:"
          curl -I "https://$DOMAIN/$CSS_FILE" || true
          exit 1
